#include "libFun.hpp"
#include "libClass.hpp"
#include <cstdio>
#include <iostream>
#include <ctime>
#include <cstdlib>

#pragma warning (disable: 4996)
#pragma warning (disable: 6031)
using namespace std;


//Funkcja wypisuje informacje dotyczaca gry
void gameInfo(void) {
	cout << "\t=========================================" << endl;
	cout << "\t|		MASTERMIND		|" << endl;
	cout << "\t=========================================\n" << endl;
	cout << "Welcome in the 'Mastermind' game." << endl;
	cout << "To win this game you have to guess the 4-colored code, that was put together by the other player, in a maximum of" << MOVES <<" moves." << endl;
	cout << "Each player gains 1 point for every wrong try of guess." << endl;
	cout << "One game consists of " << ROUNDS << " rounds." << endl;
	cout << "The winner is the player with the least amount of points." << endl;
	cout << "\nTo set up a code player has to enter a 4-character string, that represent proper set of colors:"<< endl;
	cout << "\t[R] - red\n" << "\t[G] - green\n" << "\t[B] - blue\n" << "\t[O] - orange\n" << "\t[P] - purple\n" << "\t[Y] - yellow" << endl;
	cout << "Colors can repeat in the code." << endl;
	cout << "E.g. RRBO means red, red, blue, orange" << endl;
	cout << "Rowniez w celu odganiecia kodu gracz zostanie poproszony o wpisanie ciagu 4 znakow." << endl;
	cout << "After every guess attempt computer will check the code and it will print 2 digits:\n" << "First digit represents an amount of right colors placed on the right places\n" << "Second digit represents an amount of right colors placed on the wrong places." << endl;
	cout << "E.g. for RRBO as an code and ROPR as an guess attempt it will be print [1][2] " << endl;
	cout << "\nThere are two avalible gamemodes:" << endl;
	cout << "\t1. PLAYER vs. PLAYER:\t";
	cout << "Two players are competing with each others." << endl;
	cout << "\t2. PLAYER vs. COMPUTER:\t";
	cout << "Plyer is trying to guess the code, that was randomly generated by the Computer.\n" << endl;
	cout << "After each roud you can save and quit game.\n" << endl;
	cout << "Made by: Bartosz Surma" << endl;
}
/*Funkcja zczytuje zapisany postep gry z pliku tekstowego do nowego obiektu klasy Game i zwraca ten obiekt, jezeli operacja odczytu sie powiedzie.
* W przeciwnym razie inicjalizuje nowy obiekt i rozpoczyna rozgrywke.*/
const Game loadSave(void) {
	FILE* stream;
	Game *gameplay = new Game();
	if ((stream = fopen(SAVE_NAME, "r")) == NULL) {
		cout << "\nNo saved gameplay\n" << endl;
		cout << "Start a new game:" << endl;
		initializeGameplay(*gameplay);
	}
	else {
		char nick[40] = { '\0' };
		unsigned int p, r;
		int i;
		fscanf(stream, "%s\t%d\t%d\n", nick, &p, &i);//zczytanie nicku i punktow 1. gracza
		if (!i)
			gameplay->playerOne = new Player(nick, p, i);
		else
			gameplay->playerOne = new Computer(nick, p, i);
		fscanf(stream, "%s\t%d\t%d\n", nick, &p, &i);//zczytanie nicku i punktow 2. gracza
		if (!i)
			gameplay->playerTwo = new Player(nick, p, i);
		else
			gameplay->playerTwo = new Computer(nick, p, i);
		fscanf(stream, "%d\n", &r);//zczytanie ilosci rozgranych rund
		gameplay->setRoundCounter(r);
		fclose(stream);
	}
	return *gameplay;
}
/*Funkcja wczytuje i kontynuuje zapisana wczesniej rozgrywke*/
void loadGameplay(Game&gameplay) {
	gameplay = loadSave();
	if (gameplay.getRoundCounter() == 0) {
		initializeGameplay(gameplay);
	}
	else if (gameplay.getRoundCounter() == 4)
		;
	else {
		cout << "Gameplay loaded." << endl;
		if (strcmp(gameplay.playerTwo->getNick(), PC)) {
			gameplay.gameStartPVP();
			gameplay.gameEndPvP();
		}
		else {
			gameplay.gameStartPVC();
			gameplay.gameEndPvC();
		}
	}
}
/*Funkcja rozpoczyna nowa rozgrywke*/
void initializeGameplay(Game& gameplay) {
	int temp;
	temp = gameplay.gameMode();
	switch (temp) {
	case 1:
		gameplay.gameStartPVP();
		gameplay.gameEndPvP();
		break;
	case 2:
		gameplay.gameStartPVC();
		gameplay.gameEndPvC();
		break;
	}
}
/*Funkcja wyswietla menu konca rozgrywki. Uzytkownik moze rozpoczac nowa gre, wyjsc z gry i wyswietlic historie rozgrywki.
* Funkcja zwraca wartosc true albo false*/
bool endMenu(void) {
	bool t = true;
	cout << "\nChose:" << endl;
	cout << "\t[1] - New game" << endl;
	cout << "\t[2] - Show history" << endl;
	cout << "\t[3] - End game" << endl;
	cout << "\n>>>\t";
	int m = getThreeOptions<int>();
	switch (m) {
	case 1:
		t = true;
		break;
	case 2:
		showHisotry();
		 t = endMenu();
		break;
	case 3:
		t = false;
		break;
	}
	return t;
}
/*Funkcja sprawdza aktualna date i zwraca cnapis w formacie DD.MM.RRRR*/
char* checkDate(void) {
	char buffer[80] = { '\0' };
	time_t rawdate;
	struct tm* newdate;
	time(&rawdate); //sprawdza aktualny czas
	newdate = localtime(&rawdate); //konwertuje na czas lokalny
	strftime(buffer, 80, "%d.%m.%Y", newdate);
	return buffer;
}
/*Funkcja sprawdza aktualna godzine i zwraca cnapis w formacie GG:MM*/
char* checkTime(void) {
	char buffer[80] = { '\0'};
	time_t rawtime;
	struct tm* newtime;
	time(&rawtime); //sprawdza aktualny czas
	newtime = localtime(&rawtime); //konwertuje na czas lokalny
	strftime(buffer, 80, "%H:%M", newtime);
	return buffer;
}
/*Funkcja zapisuje do pliku historie rozgrywek w kolejnosci od najnowszej do najstarszej*/
void saveHistory(Game& g) {
	gameHistory<char, 80>* head = NULL, * pointer = NULL;
	unsigned int p1, p2;
	char nick1[40] = { '\0' }, nick2[40] = { '\0' }, date[80] = { '\0' }, time[80] = { '\0' };
	strcpy(time, checkTime());
	strcpy(date, checkDate());
	FILE* stream;
	if ((stream = fopen(HISTORY_NAME, "r")) == NULL) {
		stream = fopen(HISTORY_NAME, "w");
		allocationCheck<FILE*>(stream);
		fprintf(stream, "%s\t%s\t%s\t%d\t%s\t%d\n", date, time, g.playerOne->getNick(), g.playerOne->getPoints(), g.playerTwo->getNick(), g.playerTwo->getPoints());
		fclose(stream);

	}
	else {
		//zczytanie dotyczasowego pliku
		head = pointer = new gameHistory<char, 80>;
		allocationCheck<gameHistory<char, 80>*>(head);
		fscanf(stream, "%s %s %s %d %s %d", pointer->date,pointer->time, nick1, &p1, nick2, &p2);
		pointer->playerOne = new Player(nick1, p1, 0);
		pointer->playerTwo = new Player(nick2, p2, 0);
;		pointer->next = NULL;
		while (!feof(stream)) {
			pointer->next = new gameHistory<char, 80>;
			pointer = pointer->next;
			pointer->next = NULL;
			fscanf(stream, "%s %s %s %d %s %d ", pointer->date, pointer->time, nick1, &p1, nick2, &p2);
			pointer->playerOne = new Player(nick1, p1, 0);
			pointer->playerTwo = new Player(nick2, p2, 0);
		}
		fclose(stream);
		stream = fopen(HISTORY_NAME, "w");
		allocationCheck<FILE*>(stream);
		pointer = head;
		fprintf(stream, "%s\t%s\t%s\t%d\t%s\t%d", date, time, g.playerOne->getNick(), g.playerOne->getPoints(), g.playerTwo->getNick(), g.playerTwo->getPoints());
		while (pointer != NULL) {
			fprintf(stream, "\n");
			fprintf(stream, "%s\t%s\t%s\t%d\t%s\t%d", pointer->date, pointer->time, pointer->playerOne->getNick(), pointer->playerOne->getPoints(), pointer->playerTwo->getNick(), pointer->playerTwo->getPoints());
			pointer = pointer->next;
		}
		fclose(stream);
	}
	delete head;
}
/*Funkcja zczytuje z pliku historie rozgrywek i wyswietla ja w konsoli
* W przypadku nieodnalezienia pliku z zapisem wyswietla stosowna informacje*/
void showHisotry(void) {
	FILE* stream;
	if ((stream = fopen(HISTORY_NAME, "r")) == NULL) {
		cout << "\nNo game history." << endl;
	}
	else {
		int i = 1;
		unsigned int p1, p2;
		char nick1[40] = { '\0' }, nick2[40] = { '\0' }, date[80] = { '\0' }, time[80] = { '\0' };
		cout.put('\n');
		do{
			fscanf(stream, "%s %s %s %d %s %d", date, time, nick1, &p1, nick2, &p2);
			if (strcmp(nick2, PC)) {
				cout << i++ << ". " << date << " " << time << endl;
				cout << nick1 << " - " << p1 << " points VS. " << nick2 << " - " << p2 << " points" << endl;
				cout << "Winner: " << (p1 == p2 ? "DRAW" : (p1 < p2 ? nick1 : nick2)) << "\n" << endl;
			}
			else {
				cout << i++ << ". " << date << " " << time << endl;
				cout << nick1 << " - " << p1 << " points.\n" << endl;
			}
		} while (!feof(stream));
		fclose(stream);
	}
}